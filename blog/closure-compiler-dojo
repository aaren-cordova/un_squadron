Slide #1 - Overview
	Image: Closure Compiler

	I'm going to go over some of the key features of Googles JavaScript minifier.
	Then go over the more advanced features that can change how you think and write JavaScript.
	Finally I'm going to show you on how it measures up against other compilers by using a game demo I created when I first started working here.

[Optional]
Slide #X - What is a JavaScript Compiler
	Image: JS Compiler

	JavaScript compilers take JavaScript as input, verify that the syntax is valid, then output smaller JavaScript.
	Smaller JavaScript is achieved through the removal of whitespace characters, comments and the renaming of locally declared variables and their values.

Slide #X - Why use JavaScript Compiler
	There are three main reasons to use a JS compiler:
		#1 Efficiency
			- Reduced number of HTTP requests by delivering a single JS file
			- Reduced bandwidth consumption through minification
			- Increase execution time by removing unnecessary characters such as comments and whitespace.
		#2mm Obfuscation
			- Security
				Because the original source structure is not maintained after minification, there is a level of added security that keeps others from getting their hands on the entire codebase.
			- Reversibility
				Though no JavaScript is beyond reversibility, obfuscation deters 99.99% of thieves trying to crack it.
				Software is expensive to develop, tedious to QA and devastating when stolen.
				Do you write your pass-code on the back of the phone?
				Either obfuscate all of your JavaScript or mark it as free (as in beer) for all.
		#3 Code checking
			- Compilers provide warnings for illegal JavaScript and warnings for potentially dangerous operations
			  helping you to produce JavaScript that is less buggy and easier to maintain.
		

Slide #X - Where does it fit in:
	Some well known JavaScript minifiers include:
		Image (Github Graphs)
		- UglifyJS
		- YUI Compressor
		- JSMin
		- Packer

Slide #X - How is the Closure Compiler different
	- Minification is targeted towards the GZIP size not byte size, though it's often a win for both.

	- Multiple levels of compilation
		Everything from
			- Ordered script tags during development
			- The smallest file size in production
			- Even the ability to debug minified code

	- Complex data type checking, enhancing the language without the burden of enforcing
	- Comes with a built in dependency management system, native support with RequireJS and is easy enough to put together a custom system.
		JavaScript dependency is resolved before concatenation, preventing duplicate files or plug-ins from being included.

	- A much more aggressive renaming of symbols and properties, including those at the global level.
		Beyond simple var renaming, google takes it up a notch with object property and method renaming, and renaming values in the global namespace.

	- The ability to change JavaScript values from the command line

	- The largest difference that sets it apart is the removal of dead code.
		The finalized file size is not directly proportionate to the number of total characters used, but follows the path of execution and delet

Slide #X - How can I use the Closure Compiler?
	You can use the Closure Compiler as:
		#1 Closure Compiler (Java / Node) - An open source Java application that you can run from the command line.
			[Jar file]						https://closure-compiler.googlecode.com/files/compiler-latest.zip
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-compiler
			[Github]						https://github.com/google/closure-compiler
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_app

		#2 Closure Builder (Python / Node) - An open source Python application that utilizes the Java application
			[Python - Getting Started]		https://developers.google.com/closure/library/docs/closurebuilder
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-tools

			[PHP Storm - Getting Started]	http://www.jetbrains.com/phpstorm/webhelp/minifying-javascript.html
			[PHP Storm - NodeJS]			http://plugins.jetbrains.com/plugin/6098?pr=phpStorm

			[Grunt - Closure Tools]			https://github.com/thanpolas/grunt-closure-tools
			[Grunt - Closure Compiler]		https://github.com/thanpolas/grunt-closure-compiler

		#3 A RESTful API
			[App URL]						http://closure-compiler.appspot.com/compile
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_api

		#4 A simple web application
			[App URL]					http://closure-compiler.appspot.com/home
			[Getting Started]			https://developers.google.com/closure/compiler/docs/gettingstarted_ui

(Before I get into the build modes)
Slide #X - Basic rules:
	Rule #1 :
		The first rule of the Closure Compiler, code must run without the Closure Compiler.

	Rule #2 :
		The second rule of the Closure Compiler, code MUST RUN WITHOUT the Closure Compiler!
			You will receive errors and warnings you about illegal or error prone JavaScript, it will make no attempt to correct it.
			In case you were curious as to what it considers illegal, you can configure it to target EcmaScript 3, 4 and 5 so please don't complain when it tells you that you're breaking the rules.
			That being said, you should thank be thankful a machine tells you during compilation rather than users yelling at you in production.

	Rule #3 :
		Comments are not preserved unless explicitly reserved.
			If you're trying to do use conditional comments, you will need to find alternative methods.

Slide #X - Build Modes
					[Image] Sushi
	Level 0 - RAW
			Auto generates a dependency file to be used inline with HTML.
			This allows you to dynamically load the JS files in the proper build order 
				without having to run it though the compiler each and every time or manually maintain a build order list.
			@see deps writer.
	Use : Development
{raw demo}

					[Image] PlayScript
	Level 1 - Script
			The fully concatenated unminified file
	Use : Staging
{script demo}


					[Image] Optical illusion
	Level 2 - Whitespace
				Removes unnecessary whitespace characters along with extraneous punctuation.
				
				The output JavaScript is functionally identical to the source JavaScript.
																		#The WHITESPACE_ONLY compilation level removes comments from your code and also removes line breaks, unnecessary spaces, extraneous punctuation (such as parentheses and semicolons), and other whitespace. The output JavaScript is functionally identical to the source JavaScript.
																		#This compilation level provides the least compression of the three levels.
		Use : Production (Refactoring and testing is not an option) - Refusal to give up eval or the with statement
{whitespace demo}
	[Image] Kiss
	Level 3 - Simple [Default]
		renaming local variables, parameters and optimizes expressions, preserves the functionality

		Simple Mode Rules:
			Rule #4 :
				Strings are left unaltered (for the most part)
					They are in-lined in some cases but it's but it's safe to say that the value of the string is constant

			Rule #5 :
				Strings are left UNALTERED, so eval will not work if you're expect to read local vars that have since been renamed

			Rule #6 :
				The with statement confuses the compiler because it changes lexical scope rules, compression may suffer as a result

	Use : Production - No misused evals present
				
				Functionally identical with one exception, eval statements used to access local variables.
					Rule #3 - Strings are not modified
					If the local var is renamed while the string of the eval statement remains the same, the program will fail.

																		# The SIMPLE_OPTIMIZATIONS compilation level performs the same whitespace and comment removal as WHITESPACE_ONLY, 
																		# but it also performs optimizations within expressions and functions, including renaming local variables and function parameters to shorter names. Renaming variables to shorter names makes code significantly smaller. Because the SIMPLE_OPTIMIZATIONS level renames only symbols that are local to functions, 
																		# it does not interfere with the interaction between the compiled JavaScript and other JavaScript.
																		# Compilation with SIMPLE_OPTIMIZATIONS always preserves the functionality of syntactically valid JavaScript, provided that the code does not access local variables using string names (by using eval() statements, for example).
																		# SIMPLE_OPTIMIZATIONS is the default compilation level.

{Goto whitespace demo}

	[Image] Game boy advance with evolution pic
	Level 4 - Advance | Production Optimization / Specific Build

			The crown jewel of the compiler, the size of the file is not relative to total size of the included files, but the size of the functions in use.
			Given a list of files and the insertion points, the Closure Compiler will scan the execution path and include only functions / inlined scripts that will be used or are explicitly exported.
			@see metrics

				The ADVANCED_OPTIMIZATIONS compilation level performs the same transformations as SIMPLE_OPTIMIZATIONS, but adds a variety of more aggressive global transformations to achieve the highest compression of all three levels. The ADVANCED_OPTIMIZATIONS level compresses JavaScript well beyond what is possible with other tools.

				To enable this extreme compression, ADVANCED_OPTIMIZATIONS makes strong assumptions about the compiled code. If your code does not conform to those assumptions, ADVANCED_OPTIMIZATIONS will produce code that does not run.

				For example, code compiled with ADVANCED_OPTIMIZATIONS may not work with uncompiled code unless you take special steps to ensure interoperability. If you do not flag external functions and properties referenced in your code, Closure Compiler will inappropriately rename references in your code, causing mismatches between the names in your code and in the external code.

				To learn more about how to prepare your code for ADVANCED_OPTIMIZATIONS, read Advanced Compilation and Externs.

				The ADVANCED_OPTIMIZATIONS transformations include:

				- more aggressive renaming:
					Compilation with SIMPLE_OPTIMIZATIONS only renames parameters and variables within functions. ADVANCED_OPTIMIZATIONS also renames global variables, function names, and properties.

				- dead code removal:
					Compilation with ADVANCED_OPTIMIZATIONS removes code that is provably unreachable. This is especially useful in combination with large libraries. If you use only a few functions from a large library file, the compiler can remove everything except those functions from its output.

				- global inlining:
					Compilation with ADVANCED_OPTIMIZATIONS replaces some function calls with the body of the function. This transformation is known as "inlining". The compiler only inlines functions when it determines that inlining is safe and saves space. Compilation with ADVANCED_OPTIMIZATIONS also inlines constants and some variables when the compiler determines that it can do so safely

{Advance demo}

	The Lost Level - Debug
		Main purpose: Debugging code that has been minified
		If you've ever dealt with minified code, then at some point in your career you may have seen something like the following:
			Parse error. Semi-colon expected at line 1 character 4511984


