Slide #0 - Playing with the Google Closure Compiler

	I'm going to show you two quick slides, followed by a series of js demos and snippets.
	A bulk of the demos will center around small snippets JavaScript that we will compile and this proof of concept game {show preview}.
	They demonstrate how I was able to take a (142k gzip | 823k) js file and reduce it's size by 98.7% | 92.3% (11k gzip | 30k uncompressed)
	Most of the concepts I will talk about can be applied to both the closure compiler and to uglify JS, so
	whichever you choose at the end of the day there's a little something for everyone.

	Are there any questions before we begin?

Slide #1 - Closure Tools - A collection of open source web applications, each tool works independently of one another.

	(Top Left)
	The Closure Library
		A general purpose, cross platform JavaScript library.
		If you're wondering how general, it's what powers:
			Google search
			Gmail
			maps
			Google docs 
			Along with all the products you see in the top left just to name a few

	(Top Right)
	Closure Linter
		A JavaScript style checker and style fixer, it's comparable to JSLint.

	(Bottom Left)
	Closure Templates
		An easy temperating system for both Java & JavaScript, you may akin it to handlebarsJS, mustache

	(Bottom Right)
	Closure Style Sheets
		An enhanced style-sheet language similar to LESS CSS

	(Bottom Center)
	The Closure Compiler
		A JavaScript optimizer, this is comparable
			- UglifyJS
			- YUI Compressor
			- JSMin
			- Packer

	Again, I want to point out that none of these are dependent on the other.
	That being said, they were built with the knowledge of each others existence and with that came an inherent synergy.
	For example, the closure library:
		- Enforces all rules imposed by the linter
		- Uses the optimization techniques for the compiler
		- Has additional optimization hooks built into the compiler itself
		- Directly integrates with both closure style sheets and closure templates

		This results in even higher compression rates on JS, CSS and HTML

	Does anyone have any questions before I move on to the final slide?

Slide #2 - Why use JavaScript Compiler
	There are three main reasons to use a JS compiler:
		#1 Efficiency
			- This is where a bulk of our focus will be today
			- Reduced number of HTTP requests by delivering a single JS file
			- Reduced bandwidth consumption through minification
			- Increase execution time by removing unnecessary characters such as comments and whitespace.

		#2 Obfuscation
			- Security
				Because the original source structure is not maintained after minification, there is a
				level of added security that keeps others from getting their hands on the entire codebase.
			- Reversibility
				Though no JavaScript is beyond reversibility, obfuscation deters 99.99% of thieves trying to crack it.
				That being said, I will briefly cover how to view your minified code with the fully qualified property names still intact

		#3 Code checking
			- Both linters and compilers validate that your JavaScript is EcmaScript 3 compliant
			- If time permits, I will go cover how the compiler utilizes javadocs to do data type and encapsulation checks on the prototype chain.


Slide #3 - Ways it can be used
	Java
		> Command line
		> Python
			> Closure Builder
			> Deps Writer
		> Ant
		> Java
			> DigiArea Closure FX Builder
			> DigiArea Closure IDE
	NodeJS
		> Grunt
	Rest API
			> Web Api

{Example 1.0: hello-world.compile}
	The online api uses a simple comment code block marked 'ClosureCompiler', changing the form values only modifies that comment.
	This should only be used for experimentation
	It will reject you if you try to use the public rest api too many times in a short time span


{Example 2.0: hello-world.compile}
	Description:
		Removes unnecessary whitespace characters along with extraneous punctuation.

	Result:
		The output JavaScript is functionally identical to the source JavaScript.

	Rules:
		Rule #1:
			Comments are not preserved unless explicitly marked for preservation.

	Use:
		Production - Refactoring is not an option
			Refusal to give up the with statement
			Refusal to give up the eval statement (in some cases)


{Example 3.0:simple-mode.local-var-renames.compile}
	Description:
		Renaming local variables, parameters and optimizes expressions, preserves the functionality

	Result:
		Functionally identical with one exception, eval statements used to access local variables.

	Rules:
		Rule #2 :
			Strings are left unaltered (for the most part)
				They are in-lined in some cases but it's but it's safe to say that the value of the string is is the same as the intended value.
				That also means eval will not work if you're expect to read local vars that have since been renamed.
		Rule #3 :
			Avoid the with statement
				Because it changes lexical scope rules, the with statement confuses the compiler and compression may suffer as a result.

	Use: Production - No misused evals present, with statement used with caution

{3.1-simple-mode.removal-of-dead-code.compile}
	Description:
		All dead code is removed.
		This includes all code that couldn't possible execute because it followed a throw, break, continue or return statement.
		This code technically should not exist, it's usually the result of a leftover from refactoring.

	Result:
		Functionally identical, along with optional warnings or errors if they are enabled.




Level 3 - Simple [Default]
		

		Simple Mode Rules:
			Rule #4 :
				Strings are left unaltered (for the most part)
					They are in-lined in some cases but it's but it's safe to say that the value of the string is constant

			Rule #5 :
				Strings are left UNALTERED, so eval will not work if you're expect to read local vars that have since been renamed

			Rule #6 :
				The with statement confuses the compiler because it changes lexical scope rules, compression may suffer as a result

	Use : Production - No misused evals present
				
				Functionally identical with one exception, eval statements used to access local variables.
					Rule #3 - Strings are not modified
					If the local var is renamed while the string of the eval statement remains the same, the program will fail.





	Use : Production
		Refusal to give up the with statement or the eval statement (in some cases)
		Refactoring and testing is not an option

Slide #X - How is the Closure Compiler different
	- Minification is targeted towards the GZIP size not byte size, though it's often a win for both.

	- Multiple levels of compilation
		Everything from
			- Ordered script tags during development
			- The smallest file size in production
			- Even the ability to debug minified code

	- Complex data type checking, enhancing the language without the burden of enforcing
	- Comes with a built in dependency management system, native support with RequireJS and is easy enough to put together a custom system.
		JavaScript dependency is resolved before concatenation, preventing duplicate files or plug-ins from being included.

	- A much more aggressive renaming of symbols and properties, including those at the global level.
		Beyond simple var renaming, google takes it up a notch with object property and method renaming, and renaming values in the global namespace.

	- The ability to change JavaScript values from the command line

	- The largest difference that sets it apart is the removal of dead code.
		The finalized file size is not directly proportionate to the number of total characters used, but follows the path of execution and delet

Slide #X - How can I use the Closure Compiler?
	You can use the Closure Compiler as:
		#1 Closure Compiler (Java / Node) - An open source Java application that you can run from the command line.
			[Jar file]						https://closure-compiler.googlecode.com/files/compiler-latest.zip
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-compiler
			[Github]						https://github.com/google/closure-compiler
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_app

		#2 Closure Builder (Python / Node) - An open source Python application that utilizes the Java application
			[Python - Getting Started]		https://developers.google.com/closure/library/docs/closurebuilder
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-tools

			[PHP Storm - Getting Started]	http://www.jetbrains.com/phpstorm/webhelp/minifying-javascript.html
			[PHP Storm - NodeJS]			http://plugins.jetbrains.com/plugin/6098?pr=phpStorm

			[Grunt - Closure Tools]			https://github.com/thanpolas/grunt-closure-tools
			[Grunt - Closure Compiler]		https://github.com/thanpolas/grunt-closure-compiler

		#3 A RESTful API
			[App URL]						http://closure-compiler.appspot.com/compile
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_api

		#4 A simple web application
			[App URL]					http://closure-compiler.appspot.com/home
			[Getting Started]			https://developers.google.com/closure/compiler/docs/gettingstarted_ui

(Before I get into the build modes)
Slide #X - Basic rules:
	Rule #1 :
		The first rule of the Closure Compiler, code must run without the Closure Compiler.

	Rule #2 :
		The second rule of the Closure Compiler, code MUST RUN WITHOUT the Closure Compiler!
			You will receive errors and warnings you about illegal or error prone JavaScript, it will make no attempt to correct it.
			In case you were curious as to what it considers illegal, you can configure it to target EcmaScript 3, 4 and 5 so please don't complain when it tells you that you're breaking the rules.
			That being said, you should thank be thankful a machine tells you during compilation rather than users yelling at you in production.

	Rule #3 :
		Comments are not preserved unless explicitly reserved.
			If you're trying to do use conditional comments, you will need to find alternative methods.

Slide #X - Build Modes
					[Image] Sushi
	Level 0 - RAW
			Auto generates a dependency file to be used inline with HTML.
			This allows you to dynamically load the JS files in the proper build order 
				without having to run it though the compiler each and every time or manually maintain a build order list.
			@see deps writer.
	Use : Development
{raw demo}

					[Image] PlayScript
	Level 1 - Script
			The fully concatenated unminified file
	Use : Staging
{script demo}


					[Image] Optical illusion
	Level 2 - Whitespace
				Removes unnecessary whitespace characters along with extraneous punctuation.
				
				The output JavaScript is functionally identical to the source JavaScript.
																		#The WHITESPACE_ONLY compilation level removes comments from your code and also removes line breaks, unnecessary spaces, extraneous punctuation (such as parentheses and semicolons), and other whitespace. The output JavaScript is functionally identical to the source JavaScript.
																		#This compilation level provides the least compression of the three levels.
		Use : Production (Refactoring and testing is not an option) - Refusal to give up eval or the with statement
{whitespace demo}
	[Image] Kiss
	

																		# The SIMPLE_OPTIMIZATIONS compilation level performs the same whitespace and comment removal as WHITESPACE_ONLY, 
																		# but it also performs optimizations within expressions and functions, including renaming local variables and function parameters to shorter names. Renaming variables to shorter names makes code significantly smaller. Because the SIMPLE_OPTIMIZATIONS level renames only symbols that are local to functions, 
																		# it does not interfere with the interaction between the compiled JavaScript and other JavaScript.
																		# Compilation with SIMPLE_OPTIMIZATIONS always preserves the functionality of syntactically valid JavaScript, provided that the code does not access local variables using string names (by using eval() statements, for example).
																		# SIMPLE_OPTIMIZATIONS is the default compilation level.

{Goto whitespace demo}

	[Image] Game boy advance with evolution pic
	Level 4 - Advance | Production Optimization / Specific Build

			The crown jewel of the compiler, the size of the file is not relative to total size of the included files, but the size of the functions in use.
			Given a list of files and the insertion points, the Closure Compiler will scan the execution path and include only functions / inlined scripts that will be used or are explicitly exported.
			@see metrics

				The ADVANCED_OPTIMIZATIONS compilation level performs the same transformations as SIMPLE_OPTIMIZATIONS, but adds a variety of more aggressive global transformations to achieve the highest compression of all three levels. The ADVANCED_OPTIMIZATIONS level compresses JavaScript well beyond what is possible with other tools.

				To enable this extreme compression, ADVANCED_OPTIMIZATIONS makes strong assumptions about the compiled code. If your code does not conform to those assumptions, ADVANCED_OPTIMIZATIONS will produce code that does not run.

				For example, code compiled with ADVANCED_OPTIMIZATIONS may not work with uncompiled code unless you take special steps to ensure interoperability. If you do not flag external functions and properties referenced in your code, Closure Compiler will inappropriately rename references in your code, causing mismatches between the names in your code and in the external code.

				To learn more about how to prepare your code for ADVANCED_OPTIMIZATIONS, read Advanced Compilation and Externs.

				The ADVANCED_OPTIMIZATIONS transformations include:

				- more aggressive renaming:
					Compilation with SIMPLE_OPTIMIZATIONS only renames parameters and variables within functions. ADVANCED_OPTIMIZATIONS also renames global variables, function names, and properties.

				- dead code removal:
					Compilation with ADVANCED_OPTIMIZATIONS removes code that is provably unreachable. This is especially useful in combination with large libraries. If you use only a few functions from a large library file, the compiler can remove everything except those functions from its output.

				- global inlining:
					Compilation with ADVANCED_OPTIMIZATIONS replaces some function calls with the body of the function. This transformation is known as "inlining". The compiler only inlines functions when it determines that inlining is safe and saves space. Compilation with ADVANCED_OPTIMIZATIONS also inlines constants and some variables when the compiler determines that it can do so safely

{Advance demo}

	The Lost Level - Debug
		Main purpose: Debugging code that has been minified
		If you've ever dealt with minified code, then at some point in your career you may have seen something like the following:
			Parse error. Semi-colon expected at line 1 character 4511984


