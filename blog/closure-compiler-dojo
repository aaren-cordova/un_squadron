{Turn on Wamp}
{Open Chrome}
{Open dev tools on right}
{Open Slides}
{Open Image Preview}
{Open Sublime Text}
{Pull in js folder}

Slide #0 - Playing with the Google Closure Compiler
	I'm going to show you two simple slides, 
	followed by a series js snippet demos 
	using the google online web app.

	Most of the concepts I will talk about can be applied to both uglify JS and the closure compiler, 
	so whichever you choose at the end of the day there's a little something for everyone.

	After that I will show you how I was able to go from 823k to 11k, a savings of 98.7%.
	For that, I will use a game I built as a learning exercise when I first started working here as a ad unit contractor with a online gaming background.

	The original purpose of the exercise was to gain insight all closure tools, JS OOP, HTML and CSS

{show preview}
	http://localhost/un_squadron/uncompiled-mode.html


{Ask for Questions}
	Are there any questions before we begin?




Slide #1 - Closure Tools
	Description:
		The closure compiler is part of a suite known as closure tools.
		Each of these web applications work independently of one another.

	(Top Left)
	The Closure Library
		A general purpose, cross platform JavaScript library.
		If you're wondering how general, it's what powers:
			Google search
			Gmail
			maps
			...Along with all the products you see in the top left just to name a few
			docs
			sites
			books
			blogger
			calendar
			Google+
			Images

	(Top Right)
	Closure Linter
		A JavaScript style checker and style fixer, it's comparable to JSLint and defaults to the Google Style Guide

	(Bottom Left)
	Closure Templates
		An easy temperating system for both Java & JavaScript, it is akin it to handlebarsJS, mustache

	(Bottom Right)
	Closure Style Sheets
		An enhanced style-sheet language similar to LESS CSS

	(Bottom Center)
	The Closure Compiler
		A JavaScript optimizer, this is comparable
			- UglifyJS
			- YUI Compressor
			- JSMin
			- Packer

	Again, I want to point out that none of these are dependent on one the other, they are not a package deal.
	That being said, they were built with the knowledge of each others existence and
	with that came an inherent synergy.

	For example, the closure library:
		- Enforces all rules imposed by closure linter
		- Uses the optimization techniques for the closure compiler
		- The compiler has additional hooks when it recognizing the library
		- Directly integrates with both closure style sheets and closure templates

		This results in even higher compression rates on JS, CSS and HTML

{Ask for Questions}
	Are there any questions the closure tools before I move on to the final slide?




Slide #2 - Why use JavaScript Compiler
	There are three main reasons to use a JS compiler:
		#1 Efficiency
			This is where a bulk of our focus will be today, this includes:
				- The reduction of HTTP requests by delivering a single JS file
				- Reduced bandwidth consumption through minification and
				- Increase execution time by removing unnecessary characters.

		#2 Obfuscation
			{This benefits Security}
				because the original source structure is not maintained after compilation, 
				minified code deters 99% of thieves trying to crack it.
			{Obfuscations strength is also it's weakness}
				Minified code prevents you from cracking it, resulting in unpleasant debugging.

				Though no JavaScript is beyond reversibility, towards the end of
				the demos I will cover how to debug minified code that you own
				by viewing the original var names instead of getting an error on line 1 char 2000

		#3 Code checking
			- Both linters and compilers validate that your JavaScript is EcmaScript 3 compliant
			- In addition to this the closure compiler can optionally validate that your values are the correct data type and scope
			- If time permits, I will go cover how data type checking works but
			For now, just keep it in your mind that DATA TYPE CHECKING IS NOT THE SAME AS LINTING


{Note}
	Before I get into the examples, please remember that most of the 
	concepts mentioned here can be used for both Uglify and the closure compiler
	unless I say otherwise.

{Ask for Questions}
	Are there any questions before I get into the code samples?





{Example 1.0: hello-world.compile}
	Of all the ways to get the closure compiler up and running, 
	the easiest way is to use the online web application.




	It's a great tool to experiment with, 
	just know that it will reject you if you 
	try to use it too many times in a short time span.




	Alternatively you can:
		Run the jar file from the command line via Java or Python
		Execute it in node JS
		There is also a open source REST API that you can install on your server
		Multiple grunt plugins 
		and
		A full blown IDE built specifically for closure tools

		{Overview}
			Java
				> Command line
				> Python
					> Closure Builder
					> Deps Writer
				> Ant
				> Java
					> DigiArea Closure FX Builder
					> DigiArea Closure IDE
			NodeJS
				> Grunt
			Rest API
					> Web Api
{compile}


{Questions}
	Does anyone have any questions on the alternatives?




{Example 2.0: Whitespace Mode -> compile}
	Description:
		Removes unnecessary whitespace characters along with extraneous punctuation.

	The Result is:
		Functionally identical to the source JavaScript.

	Use:
		Production - Refactoring is not an option - will cover in next example
			Refusal to give up the with statement
			Refusal to give up the eval statement (in some cases)

	Rules:
		The fist rule to take away is that:
			Comments are not preserved unless explicitly marked for preservation.
			This is important if your using conditional comments for JScript.
{Note}
			Please note the @preserve and @license JS annotations
{compile}






{Example 2.1: Simple Mode - Targeted towards G - zip -> compile}
	Another thing to keep in mind about the closure compiler is that is 
	targeted towards the G-zip size, 
	NOT byte size.
	Though it is often a win for both,
	it is possible for the byte size of a file to increase which I will demonstrate.

	To understand why this is a good thing, you have to understand how the G-Zip algorithm works.

{Question}
	Is everyone familiar with how G-Zipping algorithm works or would you like me to explain it?

		GZip finds duplicated strings in the input data.
		The second occurrence of a string is replaced by a pointer to the previous string.
		The more you repeat a string, the less it costs.

{Pick someone to make a prediction}
{compile}




{Example 3.0: Simple Mode - local var renames -> compile}
	Description:
		function parameters and local variables renamed and expressions are inlined if preferable

	The Result is:
		Functionally identical with one exception, eval statements (I will go over that in a second)
	Use: 
		Production - No misused evals present, and the with statement is used with caution

	Rules:
		Another rule to keep in mind is that:
			Strings remain unaltered (for the most part)
				They are in-lined in some cases but their original intent is preserved.
				That also means eval will not work if you're expect to read local vars because they will be renamed.
		
		You should also try not to :
			use the with statement if at all possible
				Because it changes lexical scoping rules, the compiler will have a very
				hard time resolving names and compression may suffer.
{compile}

{Note}
	Please note that the global names stay intact.




{Example 3.1: Simple mode - Removal of dead code explicit -> compile}
	Description:
		All dead code is removed, vacant, vanished.

		Dead code is anything that couldn't possible execute
		because it follows a throw, break, continue or return statement.

		This code    technically shouldn't exist, 
		it's usually the result of leftovers from a code change.

	The Result is:
		Functionally identical
		but the compiler will display warnings or errors if they are enabled.
{compile}





{3.2: Simple Mode: Conditional Compilation Shallow -> compile}
	It's easy to recognizing dead code and it's obvious why it would be removed,
	
	but there's also the concept of unreachable code.

	This will becomes more apparent when
	we combine it with compiler definitions.

	For now, just understand that all the code blocks that are
	impossible to reach are removed entirely

{Note}
	All code blocks with the "grasp" function are gone.
{compile}





{3.3 Simple Mode - Conditional Compilation Shallow -> compile}
	Description:
		As I mentioned, all code blocks that have an absolute certainty will that they will never
		execute during runtime are removed.
		The magic values are included in this snippet for sake of clarity.

{Pick someone to make a prediction}

{compile}
		This is particularly useful for including and 
		excluding modules that are significant in size if
		their use can be determined on the at the time of request.



{3.4.0: Simple Mode: Symbol Definition -> compile}
	Description:
		Both uglify and the closure compiler support 
		setting the value of a JS symbol.

		This allows entire code blocks to be removed.

{Pick someone to make a prediction}
{compile}
		In the this example, the if block is removed if the browser is known.

{Note about Uglify: the init}
	In Uglify, the init function will also be included if it is not wrapped in the if statement
	Closure will detect that the function is unused in the local scope and eliminate it.



{3.4.1-simple-mode.ehow-definition-canidates.sample}
	Please take a minute to digest that some values are known at the time of request.
	Utilizing this knowledge of conditional compilation, we have the potential to eliminate
	entire blocks of code such as jQuery plugins, tokenizers and browser specific features.

{Pick someone to think of a code block that isn't needed}


{Note}
	The remaining examples are specific to the closure compiler.



{3.5-simple-mode.conditional-compilation-deep.compile}
	Description:

		Most compilers will only perform constant folding when the constant is known and directly in the if statement.
		One of the ways the closure compiler differs is the generation of a dependency graph through the global scope and the prototype chain.
		Constant values is resolved though path of execution, that also includes methods in an instances prototype chain.
		This means complex constant folding can occur in a method, including the feature detection as a last resort.




{3.6-simple-mode.ehow-conditional-compilation-canidate.sample}
	If you put methods that contain compiler definitions to the front of your if statement, large blocks of code can be excluded.
	Refactoring this sample code with our new found knowledge, we can prevent copied and pasted code from platform to platform,
	creating a unified code-base with only platform specific changes wrapped in an if statement.

{3.7-simple-mode.ehow-conditional-compilation-canidate.sample}
	Here we have a 92kb conditional block on the ehow homepage that can be removed with the proper configuration and delivered that that specific browser.



{Note}
	Time for my favorite feature!!!

{4.0-advance-mode-example.1.removal-of-unreachable-code.compile}
	The closure compiler can be supplied the entry point of a program, and from this point create a dependancy graph.

Slide #X - How is the Closure Compiler different
	- Minification is targeted towards the GZIP size not byte size, though it's often a win for both.

	- Multiple levels of compilation
		Everything from
			- Ordered script tags during development
			- The smallest file size in production
			- Even the ability to debug minified code

	- Complex data type checking, enhancing the language without the burden of enforcing
	- Comes with a built in dependency management system, native support with RequireJS and is easy enough to put together a custom system.
		JavaScript dependency is resolved before concatenation, preventing duplicate files or plug-ins from being included.

	- A much more aggressive renaming of symbols and properties, including those at the global level.
		Beyond simple var renaming, google takes it up a notch with object property and method renaming, and renaming values in the global namespace.

	- The ability to change JavaScript values from the command line

	- The largest difference that sets it apart is the removal of dead code.
		The finalized file size is not directly proportionate to the number of total characters used, but follows the path of execution and delet

Slide #X - How can I use the Closure Compiler?
	You can use the Closure Compiler as:
		#1 Closure Compiler (Java / Node) - An open source Java application that you can run from the command line.
			[Jar file]						https://closure-compiler.googlecode.com/files/compiler-latest.zip
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-compiler
			[Github]						https://github.com/google/closure-compiler
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_app

		#2 Closure Builder (Python / Node) - An open source Python application that utilizes the Java application
			[Python - Getting Started]		https://developers.google.com/closure/library/docs/closurebuilder
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-tools

			[PHP Storm - Getting Started]	http://www.jetbrains.com/phpstorm/webhelp/minifying-javascript.html
			[PHP Storm - NodeJS]			http://plugins.jetbrains.com/plugin/6098?pr=phpStorm

			[Grunt - Closure Tools]			https://github.com/thanpolas/grunt-closure-tools
			[Grunt - Closure Compiler]		https://github.com/thanpolas/grunt-closure-compiler

		#3 A RESTful API
			[App URL]						http://closure-compiler.appspot.com/compile
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_api

		#4 A simple web application
			[App URL]					http://closure-compiler.appspot.com/home
			[Getting Started]			https://developers.google.com/closure/compiler/docs/gettingstarted_ui

(Before I get into the build modes)
Slide #X - Basic rules:
	Rule #1 :
		The first rule of the Closure Compiler, code must run without the Closure Compiler.

	Rule #2 :
		The second rule of the Closure Compiler, code MUST RUN WITHOUT the Closure Compiler!
			You will receive errors and warnings you about illegal or error prone JavaScript, it will make no attempt to correct it.
			In case you were curious as to what it considers illegal, you can configure it to target EcmaScript 3, 4 and 5 so please don't complain when it tells you that you're breaking the rules.
			That being said, you should thank be thankful a machine tells you during compilation rather than users yelling at you in production.

	Rule #3 :
		Comments are not preserved unless explicitly reserved.
			If you're trying to do use conditional comments, you will need to find alternative methods.

Slide #X - Build Modes
					[Image] Sushi
	Level 0 - RAW
			Auto generates a dependency file to be used inline with HTML.
			This allows you to dynamically load the JS files in the proper build order 
				without having to run it though the compiler each and every time or manually maintain a build order list.
			@see deps writer.
	Use : Development
{raw demo}

					[Image] PlayScript
	Level 1 - Script
			The fully concatenated unminified file
	Use : Staging
{script demo}


					[Image] Optical illusion
	Level 2 - Whitespace
				Removes unnecessary whitespace characters along with extraneous punctuation.
				
				The output JavaScript is functionally identical to the source JavaScript.
																		#The WHITESPACE_ONLY compilation level removes comments from your code and also removes line breaks, unnecessary spaces, extraneous punctuation (such as parentheses and semicolons), and other whitespace. The output JavaScript is functionally identical to the source JavaScript.
																		#This compilation level provides the least compression of the three levels.
		Use : Production (Refactoring and testing is not an option) - Refusal to give up eval or the with statement
{whitespace demo}
	[Image] Kiss
	

																		# The SIMPLE_OPTIMIZATIONS compilation level performs the same whitespace and comment removal as WHITESPACE_ONLY, 
																		# but it also performs optimizations within expressions and functions, including renaming local variables and function parameters to shorter names. Renaming variables to shorter names makes code significantly smaller. Because the SIMPLE_OPTIMIZATIONS level renames only symbols that are local to functions, 
																		# it does not interfere with the interaction between the compiled JavaScript and other JavaScript.
																		# Compilation with SIMPLE_OPTIMIZATIONS always preserves the functionality of syntactically valid JavaScript, provided that the code does not access local variables using string names (by using eval() statements, for example).
																		# SIMPLE_OPTIMIZATIONS is the default compilation level.

{Goto whitespace demo}

	[Image] Game boy advance with evolution pic
	Level 4 - Advance | Production Optimization / Specific Build

			The crown jewel of the compiler, the size of the file is not relative to total size of the included files, but the size of the functions in use.
			Given a list of files and the insertion points, the Closure Compiler will scan the execution path and include only functions / inlined scripts that will be used or are explicitly exported.
			@see metrics

				The ADVANCED_OPTIMIZATIONS compilation level performs the same transformations as SIMPLE_OPTIMIZATIONS, but adds a variety of more aggressive global transformations to achieve the highest compression of all three levels. The ADVANCED_OPTIMIZATIONS level compresses JavaScript well beyond what is possible with other tools.

				To enable this extreme compression, ADVANCED_OPTIMIZATIONS makes strong assumptions about the compiled code. If your code does not conform to those assumptions, ADVANCED_OPTIMIZATIONS will produce code that does not run.

				For example, code compiled with ADVANCED_OPTIMIZATIONS may not work with uncompiled code unless you take special steps to ensure interoperability. If you do not flag external functions and properties referenced in your code, Closure Compiler will inappropriately rename references in your code, causing mismatches between the names in your code and in the external code.

				To learn more about how to prepare your code for ADVANCED_OPTIMIZATIONS, read Advanced Compilation and Externs.

				The ADVANCED_OPTIMIZATIONS transformations include:

				- more aggressive renaming:
					Compilation with SIMPLE_OPTIMIZATIONS only renames parameters and variables within functions. ADVANCED_OPTIMIZATIONS also renames global variables, function names, and properties.

				- dead code removal:
					Compilation with ADVANCED_OPTIMIZATIONS removes code that is provably unreachable. This is especially useful in combination with large libraries. If you use only a few functions from a large library file, the compiler can remove everything except those functions from its output.

				- global inlining:
					Compilation with ADVANCED_OPTIMIZATIONS replaces some function calls with the body of the function. This transformation is known as "inlining". The compiler only inlines functions when it determines that inlining is safe and saves space. Compilation with ADVANCED_OPTIMIZATIONS also inlines constants and some variables when the compiler determines that it can do so safely

{Advance demo}

	The Lost Level - Debug
		Main purpose: Debugging code that has been minified
		If you've ever dealt with minified code, then at some point in your career you may have seen something like the following:
			Parse error. Semi-colon expected at line 1 character 4511984









