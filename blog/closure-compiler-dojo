Slide #0 - Playing with the Google Closure Compiler
	Most of the concepts I will talk about can be applied to both the closure compiler and to uglify JS, so
	whichever you choose at the end of the day there's a little something for everyone.

	I'm going to show you two quick slides, followed by a series of demos of js snippets compiled on the spot.

	After that I will show you how I will show you how I was able to go from 823k to 11k, a savings of 98.7%.
	For that, I will use a game I built as a learning exercise to gain insight all closure tools, JS OOP, HTML and CSS when
	I first started working here as a ad unit contractor with a online gaming background.

{show preview}

{Ask for Questions}
	Are there any questions before we begin?

Slide #1 - Closure Tools
	Description:
		A collection of open source web applications, each tool works independently of one another.

	(Top Left)
	The Closure Library
		A general purpose, cross platform JavaScript library.
		If you're wondering how general, it's what powers:
			Google search
			Gmail
			maps
			Google docs 
			Along with all the products you see in the top left just to name a few

	(Top Right)
	Closure Linter
		A JavaScript style checker and style fixer, it's comparable to JSLint.

	(Bottom Left)
	Closure Templates
		An easy temperating system for both Java & JavaScript, you may akin it to handlebarsJS, mustache

	(Bottom Right)
	Closure Style Sheets
		An enhanced style-sheet language similar to LESS CSS

	(Bottom Center)
	The Closure Compiler
		A JavaScript optimizer, this is comparable
			- UglifyJS
			- YUI Compressor
			- JSMin
			- Packer

	Again, I want to point out that none of these are dependent on the other.
	That being said, they were built with the knowledge of each others existence and
	with that came an inherent synergy.

	For example, the closure library:
		- Enforces all rules imposed by the linter
		- Uses the optimization techniques for the compiler
		- Has additional optimization hooks built into the compiler itself
		- Directly integrates with both closure style sheets and closure templates

		This results in even higher compression rates on JS, CSS and HTML

{Ask for Questions}
	Are there any questions the closure tools before I move on to the final slide?

Slide #2 - Why use JavaScript Compiler
	There are three main reasons to use a JS compiler:
		#1 Efficiency
			- This is where a bulk of our focus will be today
			- Reduced number of HTTP requests by delivering a single JS file
			- Reduced bandwidth consumption through minification
			- Increase execution time by removing unnecessary characters.

		#2 Obfuscation
			- Security
				Because the original source structure is not maintained after minification, there is a
				level of added security that keeps others from getting their hands on the entire codebase.
			- Reversibility
				Though no JavaScript is beyond reversibility, obfuscation deters 99.99% of thieves trying to crack it.
				That being said, I will briefly cover how to view your minified code with the fully qualified property names still intact

		#3 Code checking
			- Both linters and compilers validate that your JavaScript is EcmaScript 3 compliant
			- If time permits, I will go cover how the compiler utilizes javadocs to do data type and encapsulation checks on the prototype chain.
			For now, just keep it in your mind that DATA TYPE CHECKING IS NOT THE SAME AS LINTING

{Ask for Questions}
	Last chance

{Example 1.0: hello-world.compile}
	The online API uses a simple comment code block marked 'ClosureCompiler', changing the form values only modifies that comment.
	This should only be used for experimentation
	It will reject you if you try to use the public rest api too many times in a short time span


{Note}
	Before I get into the following examples, please remember that rules mentioned 
	here can be used for both Uglify and the closure compiler unless I say otherwise.


{Example 2.0-whitespace-mode.compile}
	Description:
		Removes unnecessary whitespace characters along with extraneous punctuation.

	Result:
		The output JavaScript is functionally identical to the source JavaScript.

	Use:
		Production - Refactoring is not an option - will cover in next example
			Refusal to give up the with statement
			Refusal to give up the eval statement (in some cases)

	Rules:
		Rule #1:
			Comments are not preserved unless explicitly marked for preservation.
{Example 2.1-simple-mode.targeted-towards-gzip.compile}
	Closure is targeted towards gzip size, NOT bytes size.
	Though it is often will get better compression in both, it is possible for the byte size of the file to increase.

	To understand why this is a good thing, you have to understand how the GZip algorithm works.
	GZip finds duplicated strings in the input data.
	The second occurrence of a string is replaced by a pointer to the previous string.
	The more you repeat a string, the less it costs.


{Example 3.0:simple-mode.local-var-renames.compile}
	Description:
		Renaming local variables, parameters and optimizes expressions, preserves the functionality

	Result:
		Functionally identical with one exception, eval statements used to access local variables.

	Use: Production - No misused evals present, with statement used with caution

	Rules:
		Rule #2 :
			Strings are left unaltered (for the most part)
				They are in-lined in some cases but it's but it's safe to say that the value of the string is is the same as the intended value.
				That also means eval will not work if you're expect to read local vars that have since been renamed.
		Rule #3 :
			Avoid the with statement
				Because it changes lexical scope rules, the with statement confuses the compiler and compression may suffer as a result.


{3.1-simple-mode.removal-of-dead-code-explicit.compile}
	Description:
		All dead code is removed.
		This includes all code that couldn't possible execute because it followed a throw, break, continue or return statement.
		This code technically should not exist, it's usually the result of a leftover from refactoring.

	Result:
		Functionally identical
		Will display warnings if they are enabled.


{3.2-simple-mode.conditional-compilation-shallow.sample}
	It's easy to recognizing dead code and obvious why it would be removed.
	The concept of unreachable code becomes more apparent when you combine it
	with compiler definitions.
	For now, just understand that all the code blocks that are impossible to reach are removed entirely

{3.3-simple-mode.conditional-compilation-shallow.compile}
	Description:
		All code blocks that have an absolute certainty will never execute in at runtime are removed.
		The constants are included in this snippet for sake of clarity, next I'll review how this knowledge is actually used.

		This is particularly useful for including and excluding modules that are significant in size if
		their use can be determined on the server-side at the time of request.

{3.4-simple-mode.symbol-definition.compile}
	Description:
		Both uglify and the closure compiler support setting the value of a JS symbol, allowing the code blocks to be remove.
		In the this example, the if block is removed if the browser is known.

		{Note about Uglify: the init}
		In Uglify, the init function will also be included if it is not wrapped in the if statement
		Closure will detect that the function is unused in the local scope and eliminate it.

{3.4a-simple-mode.ehow-definition-canidates.sample}
	Please take a minute to digest that some values are known at the time of request.
	Utilizing this knowledge of conditional compilation, we have the potential to eliminate
	entire blocks of code such as jQuery plugins, tokenizers and browser specific features.

{3.5-simple-mode.conditional-compilation-deep.compile}
	Description:
		* ! The remaining examples are specific to the closure compiler.

		Most compilers will only perform constant folding when the constant is known and directly in the if statement.
		One of the ways the closure compiler differs is the generation of a dependency graph through the global scope and the prototype chain.
		Constant values is resolved though path of execution, that also includes methods in an instances prototype chain.
		This means complex constant folding can occur in a method, including the feature detection as a last resort.

{3.6-simple-mode.ehow-conditional-compilation-canidate.sample}
	If you put methods that contain compiler definitions to the front of your if statement, large blocks of code can be excluded.
	Refactoring this sample code with our new found knowledge, we can prevent copied and pasted code from platform to platform,
	creating a unified code-base with only platform specific changes wrapped in an if statement.

{3.7-simple-mode.ehow-conditional-compilation-canidate.sample}
	Here we have a 92kb conditional block on the ehow homepage that can be removed with the proper configuration and delivered that that specific browser.



{Note}
	Time for my favorite feature!!!

{4.0-advance-mode-example.1.removal-of-unreachable-code.compile}
	The closure compiler can be supplied the entry point of a program, and from this point create a dependancy graph.

Slide #X - How is the Closure Compiler different
	- Minification is targeted towards the GZIP size not byte size, though it's often a win for both.

	- Multiple levels of compilation
		Everything from
			- Ordered script tags during development
			- The smallest file size in production
			- Even the ability to debug minified code

	- Complex data type checking, enhancing the language without the burden of enforcing
	- Comes with a built in dependency management system, native support with RequireJS and is easy enough to put together a custom system.
		JavaScript dependency is resolved before concatenation, preventing duplicate files or plug-ins from being included.

	- A much more aggressive renaming of symbols and properties, including those at the global level.
		Beyond simple var renaming, google takes it up a notch with object property and method renaming, and renaming values in the global namespace.

	- The ability to change JavaScript values from the command line

	- The largest difference that sets it apart is the removal of dead code.
		The finalized file size is not directly proportionate to the number of total characters used, but follows the path of execution and delet

Slide #X - How can I use the Closure Compiler?
	You can use the Closure Compiler as:
		#1 Closure Compiler (Java / Node) - An open source Java application that you can run from the command line.
			[Jar file]						https://closure-compiler.googlecode.com/files/compiler-latest.zip
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-compiler
			[Github]						https://github.com/google/closure-compiler
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_app

		#2 Closure Builder (Python / Node) - An open source Python application that utilizes the Java application
			[Python - Getting Started]		https://developers.google.com/closure/library/docs/closurebuilder
			[Node - Getting Started]		https://www.npmjs.org/package/grunt-closure-tools

			[PHP Storm - Getting Started]	http://www.jetbrains.com/phpstorm/webhelp/minifying-javascript.html
			[PHP Storm - NodeJS]			http://plugins.jetbrains.com/plugin/6098?pr=phpStorm

			[Grunt - Closure Tools]			https://github.com/thanpolas/grunt-closure-tools
			[Grunt - Closure Compiler]		https://github.com/thanpolas/grunt-closure-compiler

		#3 A RESTful API
			[App URL]						http://closure-compiler.appspot.com/compile
			[Getting Started]				https://developers.google.com/closure/compiler/docs/gettingstarted_api

		#4 A simple web application
			[App URL]					http://closure-compiler.appspot.com/home
			[Getting Started]			https://developers.google.com/closure/compiler/docs/gettingstarted_ui

(Before I get into the build modes)
Slide #X - Basic rules:
	Rule #1 :
		The first rule of the Closure Compiler, code must run without the Closure Compiler.

	Rule #2 :
		The second rule of the Closure Compiler, code MUST RUN WITHOUT the Closure Compiler!
			You will receive errors and warnings you about illegal or error prone JavaScript, it will make no attempt to correct it.
			In case you were curious as to what it considers illegal, you can configure it to target EcmaScript 3, 4 and 5 so please don't complain when it tells you that you're breaking the rules.
			That being said, you should thank be thankful a machine tells you during compilation rather than users yelling at you in production.

	Rule #3 :
		Comments are not preserved unless explicitly reserved.
			If you're trying to do use conditional comments, you will need to find alternative methods.

Slide #X - Build Modes
					[Image] Sushi
	Level 0 - RAW
			Auto generates a dependency file to be used inline with HTML.
			This allows you to dynamically load the JS files in the proper build order 
				without having to run it though the compiler each and every time or manually maintain a build order list.
			@see deps writer.
	Use : Development
{raw demo}

					[Image] PlayScript
	Level 1 - Script
			The fully concatenated unminified file
	Use : Staging
{script demo}


					[Image] Optical illusion
	Level 2 - Whitespace
				Removes unnecessary whitespace characters along with extraneous punctuation.
				
				The output JavaScript is functionally identical to the source JavaScript.
																		#The WHITESPACE_ONLY compilation level removes comments from your code and also removes line breaks, unnecessary spaces, extraneous punctuation (such as parentheses and semicolons), and other whitespace. The output JavaScript is functionally identical to the source JavaScript.
																		#This compilation level provides the least compression of the three levels.
		Use : Production (Refactoring and testing is not an option) - Refusal to give up eval or the with statement
{whitespace demo}
	[Image] Kiss
	

																		# The SIMPLE_OPTIMIZATIONS compilation level performs the same whitespace and comment removal as WHITESPACE_ONLY, 
																		# but it also performs optimizations within expressions and functions, including renaming local variables and function parameters to shorter names. Renaming variables to shorter names makes code significantly smaller. Because the SIMPLE_OPTIMIZATIONS level renames only symbols that are local to functions, 
																		# it does not interfere with the interaction between the compiled JavaScript and other JavaScript.
																		# Compilation with SIMPLE_OPTIMIZATIONS always preserves the functionality of syntactically valid JavaScript, provided that the code does not access local variables using string names (by using eval() statements, for example).
																		# SIMPLE_OPTIMIZATIONS is the default compilation level.

{Goto whitespace demo}

	[Image] Game boy advance with evolution pic
	Level 4 - Advance | Production Optimization / Specific Build

			The crown jewel of the compiler, the size of the file is not relative to total size of the included files, but the size of the functions in use.
			Given a list of files and the insertion points, the Closure Compiler will scan the execution path and include only functions / inlined scripts that will be used or are explicitly exported.
			@see metrics

				The ADVANCED_OPTIMIZATIONS compilation level performs the same transformations as SIMPLE_OPTIMIZATIONS, but adds a variety of more aggressive global transformations to achieve the highest compression of all three levels. The ADVANCED_OPTIMIZATIONS level compresses JavaScript well beyond what is possible with other tools.

				To enable this extreme compression, ADVANCED_OPTIMIZATIONS makes strong assumptions about the compiled code. If your code does not conform to those assumptions, ADVANCED_OPTIMIZATIONS will produce code that does not run.

				For example, code compiled with ADVANCED_OPTIMIZATIONS may not work with uncompiled code unless you take special steps to ensure interoperability. If you do not flag external functions and properties referenced in your code, Closure Compiler will inappropriately rename references in your code, causing mismatches between the names in your code and in the external code.

				To learn more about how to prepare your code for ADVANCED_OPTIMIZATIONS, read Advanced Compilation and Externs.

				The ADVANCED_OPTIMIZATIONS transformations include:

				- more aggressive renaming:
					Compilation with SIMPLE_OPTIMIZATIONS only renames parameters and variables within functions. ADVANCED_OPTIMIZATIONS also renames global variables, function names, and properties.

				- dead code removal:
					Compilation with ADVANCED_OPTIMIZATIONS removes code that is provably unreachable. This is especially useful in combination with large libraries. If you use only a few functions from a large library file, the compiler can remove everything except those functions from its output.

				- global inlining:
					Compilation with ADVANCED_OPTIMIZATIONS replaces some function calls with the body of the function. This transformation is known as "inlining". The compiler only inlines functions when it determines that inlining is safe and saves space. Compilation with ADVANCED_OPTIMIZATIONS also inlines constants and some variables when the compiler determines that it can do so safely

{Advance demo}

	The Lost Level - Debug
		Main purpose: Debugging code that has been minified
		If you've ever dealt with minified code, then at some point in your career you may have seen something like the following:
			Parse error. Semi-colon expected at line 1 character 4511984









Slide #3 - Ways it can be used
															Java
																> Command line
																> Python
																	> Closure Builder
																	> Deps Writer
																> Ant
																> Java
																	> DigiArea Closure FX Builder
																	> DigiArea Closure IDE
															NodeJS
																> Grunt
															Rest API
																	> Web Api
